# Испытание магией

Вы прошли магические методы. Начальство оценило вашу стойкость, рвение и решило дать вам испытание для подтверждения
уровня полученных навыков. Вам выпала великая честь создать полноценную программу игры в "Крестики-нолики". И вот перед
вами текст с заданием самого испытания.

**Техническое задание**
Необходимо объявить класс с именем `TicTacToe` (крестики-нолики) для управления игровым процессом. Объекты этого класса
будут создаваться командой:

```python
game = TicTacToe()
```

В каждом объекте этого класса должен быть публичный атрибут:

`pole` - двумерный кортеж, размером `3x3`.

Каждый элемент кортежа `pole` является объектом класса `Cell`:

```python
cell = Cell()
```

В объектах этого класса должно автоматически формироваться локальное свойство:

`value` - текущее значение в ячейке: `0` - клетка свободна; `1` - стоит крестик; `2` - стоит нолик.

Также с объектами класса `Cell` должна выполняться функция:

`bool(cell)` - возвращает `True`, если клетка свободна `(value = 0)` и `False` - в противном случае.

К каждой клетке игрового поля должен быть доступ через операторы:

```python
res = game[i, j]  # получение значения из клетки с индексами i, j
game[i, j] = value  # запись нового значения в клетку с индексами i, j
```

Если индексы указаны неверно (не целые числа или числа, выходящие за диапазон `[0; 2]`), то следует генерировать
исключение командой:

```python
raise IndexError('некорректно указанные индексы')
```

Чтобы в программе не оперировать величинами: `0` - свободная клетка; `1` - крестики и `2` - нолики, в классе `TicTacToe`
должны быть три публичных атрибута (атрибуты класса):

```python
FREE_CELL = 0  # свободная клетка
HUMAN_X = 1  # крестик (игрок - человек)
COMPUTER_O = 2  # нолик (игрок - компьютер)
```

В самом классе TicTacToe должны быть объявлены следующие методы (как минимум):

`init()` - инициализация игры (очистка игрового поля, возможно, еще какие-либо действия);
`show()` - отображение текущего состояния игрового поля (как именно - на свое усмотрение);
`human_go()` - реализация хода игрока (запрашивает координаты свободной клетки и ставит туда крестик);
`computer_go()` - реализация хода компьютера (ставит случайным образом нолик в свободную клетку).

Также в классе `TicTacToe` должны быть следующие объекты-свойства (`property`):

`is_human_win` - возвращает `True`, если победил человек, иначе - `False`;
`is_computer_win` - возвращает `True`, если победил компьютер, иначе - `False`;
`is_draw` - возвращает `True`, если ничья, иначе - `False`.

Наконец, с объектами класса `TicTacToe` должна выполняться функция:

`bool(game)` - возвращает `True`, если игра не окончена (никто не победил и есть свободные клетки) и `False` - в
противном случае.

Все эти функции и свойства предполагается использовать следующим образом (эти строчки в программе не писать):

```python
game = TicTacToe()
game.init()
step_game = 0
while game:
    game.show()

    if step_game % 2 == 0:
        game.human_go()
    else:
        game.computer_go()

    step_game += 1

game.show()

if game.is_human_win:
    print("Поздравляем! Вы победили!")
elif game.is_computer_win:
    print("Все получится, со временем")
else:
    print("Ничья.")
```

Вам в программе необходимо объявить только два класса: `TicTacToe` и `Cell` так, чтобы с их помощью можно было бы
сыграть в "Крестики-нолики" между человеком и компьютером.

P.S. Запускать игру и выводить что-либо на экран не нужно. Только объявить классы.

P.S.S. Домашнее задание: завершите создание этой игры и выиграйте у компьютера хотя бы один раз.

# Solution

```python
from random import choice
from itertools import chain


class TicTacToe:
    FREE_CELL = 0
    HUMAN_X = 1
    COMPUTER_O = 2

    def __init__(self):
        self.init()

    def init(self):
        self.pole = [[Cell() for _ in '***'] for __ in '***']
        self.game = True
        self.is_computer_win = False
        self.is_human_win = False
        self.is_draw = False

    def show(self):
        print(*self.pole, sep='\n')

    def __getitem__(self, item):
        return self.pole[item[0]][item[1]].value

    def check_game(self):
        free_cells = list(chain(*[[self[i, j] for i in range(3)] for j in range(3)]))
        if self.computer_win():
            self.is_computer_win = True
            self.game = False
        elif self.human_win():
            self.is_human_win = True
            self.game = False
        elif TicTacToe.FREE_CELL not in free_cells:
            self.game = False
            self.is_draw = True

    def __setitem__(self, item, value):
        self.pole[item[0]][item[1]].value = value
        self.pole[item[0]][item[1]].is_free = False
        self.check_game()


    def go(self, player):
        free_cells = list(chain(*[[(i, j) for i in range(3) if self.pole[i][j]] for j in range(3)]))
        self[choice(free_cells)] = Cell(player)
        self.check_game()

    def human_go(self):
        self.go(TicTacToe.HUMAN_X)

    def computer_go(self):
        self.go(TicTacToe.COMPUTER_O)

    def win(self, player):
        y = (((0,0),(0,1),(0,2)), ((1,0),(1,1),(1,2)), ((2,0),(2,1),(2,2)), ((0,0),(1,0),(2,0)),
             ((0,1),(1,1),(2,1)), ((0,2),(1,2),(2,2)), ((0,0),(1,1),(2,2)), ((0,2),(1,1),(2,0)))
        return any((set(map(lambda x: self[x], i)) == {player} for i in y))

    def human_win(self):
        self.is_human_win = self.win(TicTacToe.HUMAN_X)

    def computer_win(self):
        self.is_computer_win = self.win(TicTacToe.COMPUTER_O)

    def __bool__(self):
        return self.game


class Cell:

    def __init__(self, value=0):
        self.__value = value
        self.is_free = self.value == 0

    def __bool__(self):
        return self.is_free

    def __repr__(self):
        return str(self.value)

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, val):
        self.__value = val
        self.is_free = val == 0
```